# 정보 구조 설계 (IA): 정중한 문장 도우미 (business-message)

> **문서 버전:** 1.0  
> **기준 문서:** PRD v1.0, TRD v1.0, Code Guideline v1.0  
> **작성일:** 2025-08-30  
> **대상 단계:** Phase 1 (MVP)

## 1. 개요 (Overview)

본 문서는 '정중한 문장 도우미' 크롬 확장 프로그램의 Phase 1 (MVP) 버전의 정보 구조(Information Architecture)를 정의합니다. 사용자가 접하게 될 화면의 구성 요소, 콘텐츠 계층 구조, 그리고 화면 간의 흐름(Flow)을 명확히 하여 일관되고 직관적인 사용자 경험의 기반을 마련하는 것을 목표로 합니다.

## 2. 설계 목표 및 원칙

  - **목표:** 사용자가 '텍스트 복사 → 아이콘 클릭 → 결과 붙여넣기'라는 핵심 플로우를 최소한의 인지적 노력으로 완수할 수 있도록 지원하는 직관적인 구조를 설계합니다.

  - **설계 원칙:**

      - **즉시성 (Immediacy):** 가장 중요한 기능(문장 변환)과 결과(격식 톤)를 즉시 제공하여 사용자가 클릭 한 번으로 가치를 얻게 합니다.
      - **단순성 (Simplicity):** MVP 단계에서는 부가 기능을 최소화하고, 필수적인 요소만 명확하게 노출하여 복잡성을 제거합니다.
      - **명확성 (Clarity):** 모든 UI 요소(버튼, 레이블, 메시지)는 그 기능과 상태를 명확하게 전달해야 합니다.

## 3. 사용자 시나리오 (Key Scenario)

> **"2~10년 차 직장인 A는 상사에게 보낼 이메일을 작성하던 중, 더 정중한 표현이 필요하다고 느낀다. 그는 문장을 복사한 뒤 확장 프로그램 아이콘을 클릭하여 즉시 변환된 문장을 얻고, 이를 이메일에 붙여넣는다."**

## 4. 화면 구조 및 흐름 (Screen Flow)

본 확장 프로그램은 **팝업(Popup)**과 **설정(Options)**, 두 개의 주요 화면으로 구성됩니다.

```
+--------------------------+
|  Chrome Browser Toolbar  |
|      [확장 프로그램 아이콘]  |
+--------------------------+
           |
         (클릭)
           |
           v
+--------------------------+      (설정 아이콘 클릭)      +-----------------------------+
|      1. 팝업 화면        | ----------------------> |       2. 설정 화면          |
|  (Popup Window)          |                         |  (Options Page in New Tab)  |
|                          |                         |                             |
|  - 원본 텍스트 입력 영역     |                         |  - API 키 관리 섹션         |
|  - 액션 바 (재생성, 카운터) |                         |                             |
|  - 결과 카드 표시 영역     |                         |                             |
+--------------------------+                         +-----------------------------+
```

## 5. 콘텐츠 인벤토리 및 화면 상세 설계

### 5.1. 팝업 화면 (Popup Window)

  - **설명:** 확장 프로그램의 핵심 기능이 실행되는 메인 화면입니다. 사용자가 아이콘을 클릭했을 때 나타납니다.
  - **파일:** `popup.html`, `Popup.tsx`

| ID | 요소 (Element) | 콘텐츠 / 상태 (Content / State) | 기능 / 동작 (Function / Action) | 비고 |
| --- | --- | --- | --- | --- |
| **P-1** | **헤더** | - 제목: "정중한 문장 도우미"<br>- 아이콘: 설정 페이지로 이동하는 톱니바퀴 아이콘 | - 클릭 시 `options.html`을 새 탭에서 연다. | |
| **P-2** | **원본 텍스트 입력 영역** | - **기본:** 클립보드에서 읽어온 텍스트<br>- **클립보드 비어있을 시:** "변환할 텍스트를 복사하거나, 직접 입력해주세요." 플레이스홀더<br>- **하단:** 글자 수 카운터 (예: 25/500) | - 팝업이 열릴 때 `navigator.clipboard.readText()`로 자동 채움.<br>- 사용자가 직접 수정/입력 가능. | 500자 초과 시 경고 UI 표시 |
| **P-3** | **액션 바** | - 버튼: "다시 생성"<br>- 텍스트: "오늘 남은 횟수: X/5" | - **다시 생성:** 현재 입력된 텍스트로 API 재호출.<br>- **남은 횟수:** API 호출 성공 시 1씩 차감. | |
| **P-4** | **결과 표시 영역** | - **로딩 상태:** 스피너 또는 스켈레톤 UI<br>- **오류 상태:** 오류 메시지 텍스트 (예: "API 서버 응답에 실패했습니다.")<br>- **성공 상태:** 3개의 결과 카드(P-5) 표시 | - API 호출 상태에 따라 동적으로 UI 변경. | |
| **P-5** | **결과 카드 (Component)** | - **레이블:** "격식", "일반", "친근"<br>- **내용:** AI가 변환한 문장 텍스트<br>- **아이콘:** 복사하기 아이콘 | - API 응답 JSON 객체(`formal`, `general`, `friendly`)를 기반으로 3개 생성.<br>- **복사 아이콘 클릭:** 해당 카드의 텍스트를 클립보드에 복사(`navigator.clipboard.writeText()`). | 기본값('격식')은 생성 즉시 자동 복사됨 |

### 5.2. 설정 화면 (Options Page)

  - **설명:** 사용자가 자신의 API 키를 관리하는 별도의 설정 페이지입니다.
  - **파일:** `options.html`, `Settings.tsx`

| ID | 요소 (Element) | 콘텐츠 / 상태 (Content / State) | 기능 / 동작 (Function / Action) | 비고 |
| --- | --- | --- | --- | --- |
| **O-1** | **헤더** | - 제목: "설정" | | |
| **O-2** | **API 키 관리 섹션** | - **제목:** "Google Gemini API 키 설정"<br>- **안내문:** API 키 발급 방법에 대한 간단한 설명 및 링크<br>- **입력 필드:** `type="password"`로 마스킹 처리된 입력창<br>- **버튼:** "연결 테스트", "저장"<br>- **상태 메시지:** "저장되었습니다.", "연결 성공!", "유효하지 않은 키입니다. 다시 확인해주세요." | - **연결 테스트:** 입력된 키로 테스트 API를 호출하여 유효성 검증.<br>- **저장:** 유효한 키를 `chrome.storage.local`에 암호화하여 저장. | TRD 6.1절의 암호화 요구사항 준수 |
| **O-3** | **기타 정보 섹션** | - 개인정보처리방침 링크<br>- 개발자 연락처 또는 피드백 채널 | - 클릭 시 해당 페이지로 이동. | |

## 6. 데이터 스키마 (Data Schema)

  - **설명:** `chrome.storage.local`에 저장될 데이터의 구조를 정의합니다.
  - **참고:** `TRD 5절`, `CODE_GUIDELINE 7.1절`

<!-- end list -->

```typescript
// src/types/index.ts
interface AppStorage {
  // 사용자의 암호화된 API 키
  userApiKey: string;

  // 일일 사용량 추적 객체
  dailyUsage: {
    date: string;  // 'YYYY-MM-DD'
    count: number; // 사용 횟수
  };
}
```
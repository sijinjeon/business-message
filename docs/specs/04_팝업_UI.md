# 기능 상세 스펙 문서 - 04. 팝업 UI

> **문서 버전**: 1.0  
> **작성일**: 2025-12-25  
> **담당 모듈**: `src/popup/App.tsx`, `src/popup/components/`

---

## 목차

1. [개요](#1-개요)
2. [UI 구조](#2-ui-구조)
3. [컴포넌트 명세](#3-컴포넌트-명세)
4. [상태 관리](#4-상태-관리)
5. [사용자 인터랙션](#5-사용자-인터랙션)
6. [에러 및 로딩 상태](#6-에러-및-로딩-상태)

---

## 1. 개요

### 1.1 팝업 UI 정의

**팝업**은 Chrome Extension의 메인 인터페이스로, 사용자가 툴바 아이콘을 클릭하면 나타나는 작은 창입니다.

**크기**:
- 너비: 400px (고정)
- 높이: 600px (초기), 최대 700px (스크롤 가능)

**트리거**:
1. 툴바 아이콘 클릭
2. 단축키 (Cmd+Option+C: 정중한 문장 모드)

### 1.2 핵심 기능

- ✅ 클립보드 텍스트 자동 읽기
- ✅ 3가지 톤 변환 (Formal, General, Friendly)
- ✅ 결과 클립보드 복사
- ✅ 재생성 기능
- ✅ 설정 페이지 바로가기

---

## 2. UI 구조

### 2.1 전체 레이아웃

```
┌─────────────────────────────────────────────┐
│  Header (헤더)                              │  48px
├─────────────────────────────────────────────┤
│  Provider Selector (AI 제공업체 선택)       │  80px
├─────────────────────────────────────────────┤
│  Text Input (텍스트 입력)                   │  140px
├─────────────────────────────────────────────┤
│  Action Bar (액션 버튼)                     │  48px
├─────────────────────────────────────────────┤
│  Message (성공/에러 메시지)                 │  가변
├─────────────────────────────────────────────┤
│  Results (결과 영역)                        │  가변
│  - Loading (로딩 상태)                      │
│  - Result Cards (결과 카드 3개)             │
└─────────────────────────────────────────────┘

총 높이: ~600px (초기), 스크롤 가능
```

### 2.2 컴포넌트 계층

```
App (Container)
├── Header
│   ├── Title: "정중한 문장 도우미"
│   └── (Settings 버튼은 ActionBar로 이동)
├── Provider Selector
│   ├── Label: "AI 제공업체"
│   └── Select: Gemini / ChatGPT / Claude
├── TextInput
│   ├── Textarea (120px 높이)
│   ├── Character Counter
│   └── Warning (길이 초과 시)
├── ActionBar
│   ├── Button: 클립보드 읽기
│   ├── Button: 다시 생성
│   └── Button: 설정
├── Message (조건부)
│   └── Alert: 성공/에러 메시지
└── Results
    ├── Loading State (Skeleton × 3)
    └── Success State
        ├── ResultCard: 비즈니스 이메일 (기본)
        ├── ResultCard: 사내 메신저
        └── ResultCard: 캐주얼 채팅
```

---

## 3. 컴포넌트 명세

### 3.1 App.tsx (메인 컨테이너)

**파일**: `src/popup/App.tsx`  
**라인 수**: 270 lines

**State 정의**:
```typescript
interface AppState {
  inputText: string;              // 입력 텍스트
  results: AIApiResponse | null;  // 변환 결과
  loadingState: LoadingState;     // 'idle' | 'loading' | 'success' | 'error'
  message: string;                // 사용자 메시지
  messageType: 'error' | 'success' | '';  // 메시지 타입
  remainingUsage: number;         // 남은 사용 횟수 (미사용)
}
```

**주요 함수**:
```typescript
// 초기화
const initializeApp = async () => {
  const clipboardText = await readClipboard()
  const provider = await getSelectedProvider()
  setState({ inputText: clipboardText, ... })
  
  if (clipboardText) {
    await handleConvert(clipboardText)
  }
}

// 텍스트 변환
const handleConvert = async (text?: string) => {
  // 1. 입력 검증
  // 2. API 키 조회
  // 3. API 호출
  // 4. 결과 표시
  // 5. 자동 복사 (설정 시)
}

// 클립보드 복사
const handleCopy = useCallback(async (text: string) => {
  await writeClipboard(text)
}, [])

// 설정 페이지 열기
const handleOpenSettings = useCallback(() => {
  chrome.runtime.openOptionsPage()
}, [])

// 입력 변경
const handleInputChange = useCallback((value: string) => {
  setState(prev => ({ ...prev, inputText: value }))
}, [])

// 클립보드 다시 읽기
const handleReadClipboard = useCallback(async () => {
  const text = await readClipboard()
  setState({ inputText: text })
  if (text) await handleConvert(text)
}, [])
```

**JSX 구조**:
```tsx
return (
  <div className="w-full h-full p-4 space-y-4">
    {/* 헤더 */}
    <div className="flex items-center justify-between">
      <h1 className="text-lg font-semibold">정중한 문장 도우미</h1>
    </div>
    
    {/* AI 제공업체 선택 */}
    <div className="space-y-2">
      <label className="text-sm font-medium">AI 제공업체</label>
      <Select value={selectedProvider} onValueChange={handleProviderChange}>
        <SelectItem value="gemini">Google Gemini</SelectItem>
        <SelectItem value="chatgpt">ChatGPT</SelectItem>
        <SelectItem value="claude">Claude</SelectItem>
      </Select>
    </div>
    
    {/* 텍스트 입력 */}
    <TextInput
      value={state.inputText}
      onChange={handleInputChange}
      maxLength={0}
      placeholder="변환할 텍스트를 복사하거나, 직접 입력해주세요."
    />
    
    {/* 액션 바 */}
    <ActionBar
      onRegenerate={() => handleConvert()}
      onReadClipboard={handleReadClipboard}
      isLoading={state.loadingState === 'loading'}
      onOpenSettings={handleOpenSettings}
    />
    
    {/* 메시지 */}
    {state.message && (
      <Alert variant={state.messageType === 'error' ? 'destructive' : 'default'}>
        <AlertDescription>{state.message}</AlertDescription>
      </Alert>
    )}
    
    {/* 결과 영역 */}
    <div className="space-y-3">
      {state.loadingState === 'loading' && (
        <>
          <Skeleton className="h-32" />
          <Skeleton className="h-32" />
          <Skeleton className="h-32" />
        </>
      )}
      
      {state.results && (
        <>
          <ResultCard tone="formal" text={state.results.formal} 
                      onCopy={handleCopy} isDefaultSelected />
          <ResultCard tone="general" text={state.results.general} 
                      onCopy={handleCopy} />
          <ResultCard tone="friendly" text={state.results.friendly} 
                      onCopy={handleCopy} />
        </>
      )}
    </div>
  </div>
)
```

### 3.2 TextInput 컴포넌트

**파일**: `src/popup/components/TextInput.tsx`  
**라인 수**: 54 lines

**Props**:
```typescript
interface TextInputProps {
  value: string;              // 현재 입력값
  onChange: (value: string) => void;  // 변경 핸들러
  maxLength: number;          // 최대 길이 (0: 무제한)
  placeholder: string;        // 플레이스홀더 텍스트
}
```

**기능**:
- Textarea 입력 컴포넌트
- 글자 수 카운터 표시
- 길이 초과 시 경고 (maxLength > 0일 때)
- React.memo로 최적화

**렌더링**:
```tsx
<div className="space-y-2">
  <Textarea
    value={value}
    onChange={(e) => onChange(e.target.value)}
    placeholder={placeholder}
    className={`min-h-[120px] resize-none ${
      isOverLimit ? 'border-destructive' : ''
    }`}
  />
  <div className="flex justify-end">
    <span className={`text-xs ${
      isOverLimit ? 'text-destructive' : 'text-muted-foreground'
    }`}>
      {characterCount}자
    </span>
  </div>
</div>
```

### 3.3 ActionBar 컴포넌트

**파일**: `src/popup/components/ActionBar.tsx`  
**라인 수**: 48 lines

**Props**:
```typescript
interface ActionBarProps {
  onRegenerate: () => void;       // 다시 생성 버튼
  onReadClipboard: () => void;    // 클립보드 읽기 버튼
  isLoading: boolean;             // 로딩 상태
  onOpenSettings: () => void;     // 설정 열기
}
```

**버튼 구성**:
1. **클립보드 읽기**: Outline 스타일, Clipboard 아이콘
2. **다시 생성**: Secondary 스타일, RotateCw 아이콘 (로딩 시 회전)
3. **설정**: Ghost 스타일, Settings 아이콘

**렌더링**:
```tsx
<div className="flex items-center justify-between py-3">
  <div className="flex items-center gap-2">
    <Button variant="outline" size="sm" onClick={onReadClipboard}>
      <Clipboard className="h-4 w-4" />
      클립보드 읽기
    </Button>
    <Button variant="secondary" size="sm" onClick={onRegenerate}>
      <RotateCw className={`h-4 w-4 ${isLoading ? 'animate-spin' : ''}`} />
      다시 생성
    </Button>
    <Button variant="ghost" size="sm" onClick={onOpenSettings}>
      <Settings className="h-4 w-4" />
    </Button>
  </div>
</div>
```

### 3.4 ResultCard 컴포넌트

**파일**: `src/popup/components/ResultCard.tsx`  
**라인 수**: 70 lines

**Props**:
```typescript
interface ResultCardProps {
  tone: 'formal' | 'general' | 'friendly';  // 톤 타입
  text: string;                             // 변환된 텍스트
  onCopy: (text: string) => void;           // 복사 핸들러
  isDefaultSelected?: boolean;              // 기본 선택 여부
}
```

**내부 상태**:
```typescript
const [isCopied, setIsCopied] = useState(false)
```

**톤 레이블 매핑**:
```typescript
const TONE_LABELS = {
  formal: '비즈니스 이메일',
  general: '사내 메신저',
  friendly: '캐주얼 채팅'
}
```

**기능**:
1. 톤별 레이블 표시
2. 변환된 텍스트 표시
3. 복사 버튼 (아이콘만)
4. 복사 성공 시 체크 아이콘 (2초간)
5. 기본 선택 시 링 테두리 + 배지

**렌더링**:
```tsx
<Card className={`relative ${isDefaultSelected ? 'ring-2 ring-primary' : ''}`}>
  <CardHeader className="pb-2">
    <CardTitle className="text-sm font-medium flex items-center justify-between">
      <span>{label}</span>
      {isDefaultSelected && (
        <span className="text-xs text-primary bg-primary/10 px-2 py-1 rounded">
          기본 선택
        </span>
      )}
    </CardTitle>
  </CardHeader>
  <CardContent className="pt-0">
    <p className="text-sm leading-relaxed mb-3 min-h-[60px]">
      {text}
    </p>
    <div className="flex justify-end">
      <Button variant="ghost" size="sm" onClick={handleCopy}>
        {isCopied ? (
          <Check className="h-4 w-4 text-green-600" />
        ) : (
          <Copy className="h-4 w-4" />
        )}
      </Button>
    </div>
  </CardContent>
</Card>
```

---

## 4. 상태 관리

### 4.1 App State

```typescript
const INITIAL_STATE: AppState = {
  inputText: '',
  results: null,
  loadingState: 'idle',
  message: '',
  messageType: '',
  remainingUsage: 0
}

const [state, setState] = useState<AppState>(INITIAL_STATE)
const [selectedProvider, setSelectedProviderState] = useState<AIProvider>('gemini')
```

### 4.2 상태 전이 다이어그램

```
idle (초기 상태)
   ↓ [팝업 열림]
   ↓
클립보드 읽기
   ↓ [텍스트 있음]
   ↓
loading (API 호출 중)
   ↓
   ├─→ success (성공)
   │     ↓
   │   결과 표시
   │     ↓
   │   idle (3초 후 메시지 제거)
   │
   └─→ error (실패)
         ↓
       에러 메시지 표시
         ↓
       idle (사용자 재시도 대기)
```

### 4.3 부수 효과 (useEffect)

```typescript
// 초기화
useEffect(() => {
  initializeApp()
}, [])

// 초기화 함수
const initializeApp = async () => {
  try {
    // 1. 클립보드 읽기
    const clipboardText = await readClipboard()
    
    // 2. 제공업체 로드
    const provider = await getSelectedProvider()
    
    // 3. 상태 업데이트
    setState(prev => ({
      ...prev,
      inputText: clipboardText,
      remainingUsage: 0
    }))
    
    setSelectedProviderState(provider)
    
    // 4. 자동 변환 (텍스트가 있으면)
    if (clipboardText) {
      await handleConvert(clipboardText)
    }
  } catch (error) {
    console.error('Initialization error:', error)
  }
}
```

---

## 5. 사용자 인터랙션

### 5.1 인터랙션 맵

```
[클립보드 읽기 버튼]
   ↓
readClipboard()
   ↓
입력창 업데이트
   ↓
자동 변환 시작

[다시 생성 버튼]
   ↓
handleConvert()
   ↓
API 호출
   ↓
결과 업데이트

[복사 버튼] (각 ResultCard)
   ↓
writeClipboard(text)
   ↓
아이콘 변경 (Copy → Check, 2초)

[설정 버튼]
   ↓
chrome.runtime.openOptionsPage()
   ↓
새 탭에서 설정 페이지 열림

[AI 제공업체 변경]
   ↓
setSelectedProvider(provider)
   ↓
Storage 저장
```

### 5.2 키보드 단축키 (팝업 내)

| 키 | 액션 |
|----|------|
| `Ctrl/Cmd + Enter` | 변환 실행 |
| `Ctrl/Cmd + 1` | 첫 번째 결과 복사 |
| `Ctrl/Cmd + 2` | 두 번째 결과 복사 |
| `Ctrl/Cmd + 3` | 세 번째 결과 복사 |
| `Ctrl/Cmd + ,` | 설정 열기 |
| `Esc` | 팝업 닫기 |

**구현** (향후 개선):
```typescript
useEffect(() => {
  const handleKeyDown = (e: KeyboardEvent) => {
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
      e.preventDefault()
      handleConvert()
    }
    // ... 다른 단축키
  }
  
  window.addEventListener('keydown', handleKeyDown)
  return () => window.removeEventListener('keydown', handleKeyDown)
}, [])
```

---

## 6. 에러 및 로딩 상태

### 6.1 로딩 상태

**시각적 표현**: Skeleton 컴포넌트

```tsx
{state.loadingState === 'loading' && (
  <>
    <Skeleton className="h-32" />
    <Skeleton className="h-32" />
    <Skeleton className="h-32" />
  </>
)}
```

**Skeleton 스타일**:
- 높이: 128px (32 × 4)
- 배경: 회색 그라데이션 애니메이션
- 둥근 모서리: 0.5rem

**로딩 시간**: 평균 1-2초

### 6.2 에러 상태

**표시 방식**: Alert 컴포넌트 (destructive variant)

```tsx
{state.message && state.messageType === 'error' && (
  <Alert variant="destructive">
    <AlertDescription>{state.message}</AlertDescription>
  </Alert>
)}
```

**에러 메시지 목록**:

| 상황 | 메시지 |
|------|--------|
| 텍스트 없음 | "변환할 텍스트를 입력해주세요." |
| API 키 없음 | "API 키가 설정되지 않았습니다. 설정 페이지에서 API 키를 입력해주세요." |
| API 키 무효 | "[제공업체] API 키가 유효하지 않습니다. 설정 페이지에서 확인해주세요." |
| 서버 오류 | "[제공업체] 서버에 문제가 발생했습니다. 잠시 후 다시 시도해주세요." |
| 네트워크 오류 | "네트워크 연결을 확인해주세요." |

### 6.3 성공 상태

**표시 방식**: Alert 컴포넌트 (default variant) + 성공 아이콘

```tsx
{state.message && state.messageType === 'success' && (
  <Alert>
    <AlertDescription>{state.message}</AlertDescription>
  </Alert>
)}
```

**성공 메시지**:
```
"✅ 비즈니스 이메일 결과가 클립보드에 복사되었습니다!"
```

**자동 제거**: 3초 후 메시지 제거

```typescript
setTimeout(() => {
  setState(prev => ({ ...prev, message: '', messageType: '' }))
}, 3000)
```

---

## 7. 성능 최적화

### 7.1 React 최적화

**컴포넌트 메모이제이션**:
```typescript
export default React.memo(TextInput)
export default React.memo(ActionBar)
export default React.memo(ResultCard)
```

**Callback 메모이제이션**:
```typescript
const handleCopy = useCallback(async (text: string) => {
  await writeClipboard(text)
}, [])

const handleOpenSettings = useCallback(() => {
  chrome.runtime.openOptionsPage()
}, [])
```

### 7.2 렌더링 최적화

**조건부 렌더링**:
```tsx
{/* 로딩 중에만 Skeleton */}
{state.loadingState === 'loading' && <Skeleton />}

{/* 결과가 있을 때만 ResultCard */}
{state.results && <ResultCard />}
```

**불필요한 리렌더링 방지**:
```typescript
// ❌ Bad: 매번 새 객체 생성
<TextInput onChange={(value) => setState({ ...state, inputText: value })} />

// ✅ Good: useCallback 사용
const handleInputChange = useCallback((value: string) => {
  setState(prev => ({ ...prev, inputText: value }))
}, [])
```

---

## 8. 접근성 (Accessibility)

### 8.1 키보드 네비게이션

**Tab 순서**:
```
1. AI 제공업체 Select
2. Textarea (입력창)
3. 클립보드 읽기 버튼
4. 다시 생성 버튼
5. 설정 버튼
6. 첫 번째 결과 카드 복사 버튼
7. 두 번째 결과 카드 복사 버튼
8. 세 번째 결과 카드 복사 버튼
```

**포커스 스타일**:
```css
focus:ring-2 focus:ring-primary focus:ring-offset-2
```

### 8.2 ARIA 레이블

```tsx
<Button
  aria-label="클립보드에서 텍스트 읽기"
  onClick={onReadClipboard}
>
  <Clipboard className="h-4 w-4" />
  클립보드 읽기
</Button>

<Textarea
  aria-label="변환할 텍스트 입력"
  aria-describedby="char-count"
  placeholder="..."
/>

<span id="char-count" className="text-xs">
  {count}자
</span>
```

### 8.3 스크린 리더

**상태 변화 알림**:
```tsx
<div role="status" aria-live="polite" aria-atomic="true">
  {state.loadingState === 'loading' && '변환 중입니다...'}
  {state.loadingState === 'success' && '변환이 완료되었습니다.'}
  {state.loadingState === 'error' && state.message}
</div>
```

---

## 9. 테스트 시나리오

### 9.1 기능 테스트

```typescript
describe('Popup UI Tests', () => {
  test('팝업 초기화 - 클립보드 자동 읽기', async () => {
    // Mock clipboard
    navigator.clipboard.readText = jest.fn()
      .mockResolvedValue('test text')
    
    const { getByRole } = render(<App />)
    
    await waitFor(() => {
      const textarea = getByRole('textbox')
      expect(textarea).toHaveValue('test text')
    })
  })
  
  test('다시 생성 버튼 클릭', async () => {
    const { getByText } = render(<App />)
    
    const button = getByText('다시 생성')
    fireEvent.click(button)
    
    await waitFor(() => {
      expect(mockConvertAPI).toHaveBeenCalled()
    })
  })
  
  test('복사 버튼 클릭', async () => {
    const { getAllByRole } = render(<ResultCard text="test" />)
    
    const copyButton = getAllByRole('button')[0]
    fireEvent.click(copyButton)
    
    await waitFor(() => {
      expect(navigator.clipboard.writeText)
        .toHaveBeenCalledWith('test')
    })
  })
})
```

### 9.2 사용자 플로우 테스트

**시나리오 1: 정상 플로우**
```
1. 팝업 열기
2. 클립보드 텍스트 자동 로드 확인
3. 자동 변환 시작 확인
4. 로딩 스켈레톤 표시 확인
5. 2초 후 결과 표시 확인
6. 자동 복사 확인 (클립보드 내용 검증)
7. 복사 버튼 수동 클릭 테스트
```

**시나리오 2: 에러 플로우**
```
1. API 키 없이 팝업 열기
2. 에러 메시지 표시 확인
3. 설정 버튼 클릭
4. 설정 페이지 열림 확인
```

---

## 10. 개선 계획

### 10.1 단기 개선

1. **키보드 단축키**
   - Ctrl+Enter: 변환 실행
   - Ctrl+1/2/3: 각 결과 복사

2. **사용량 카운터**
   - 남은 횟수 표시 (현재 코드에 있으나 UI 미표시)

3. **토스트 알림**
   - shadcn/ui Toast 완전 통합

### 10.2 중기 개선

1. **히스토리**
   - 최근 변환 이력 저장
   - 빠른 재사용

2. **즐겨찾기**
   - 자주 사용하는 문장 저장

---

**문서 작성**: AI 코드 분석 시스템  
**최종 업데이트**: 2025-12-25


# 기능 상세 스펙 문서 - 02. AI 통합

> **문서 버전**: 1.0  
> **작성일**: 2025-12-25  
> **담당 모듈**: `src/utils/api.ts`

---

## 목차

1. [개요](#1-개요)
2. [AI 제공업체](#2-ai-제공업체)
3. [시스템 프롬프트](#3-시스템-프롬프트)
4. [API 통합](#4-api-통합)
5. [응답 처리](#5-응답-처리)
6. [에러 처리](#6-에러-처리)
7. [성능 최적화](#7-성능-최적화)

---

## 1. 개요

### 1.1 목적

3개의 주요 AI 제공업체 (Google Gemini, OpenAI ChatGPT, Anthropic Claude)와 통합하여 텍스트를 3가지 톤으로 변환하는 기능을 제공합니다.

### 1.2 핵심 요구사항

- ✅ 3개 AI 제공업체 지원
- ✅ 통일된 인터페이스 제공
- ✅ 3가지 톤 변환 (Formal, General, Friendly)
- ✅ JSON 형식 강제 응답
- ✅ 한국 직장 문화 맞춤 프롬프트

### 1.3 관련 파일

```
src/utils/api.ts       # AI API 통합 로직 (366 lines)
src/types/index.ts     # API 타입 정의
```

---

## 2. AI 제공업체

### 2.1 지원 제공업체

```typescript
export const AI_PROVIDERS = {
  gemini: {
    name: 'Google Gemini',
    description: 'Google의 최신 AI 모델',
    model: 'gemini-2.0-flash-exp'
  },
  chatgpt: {
    name: 'ChatGPT',
    description: 'OpenAI의 GPT 모델',
    model: 'gpt-4o-mini'
  },
  claude: {
    name: 'Claude',
    description: 'Anthropic의 Claude 모델',
    model: 'claude-3-5-haiku-20241022'
  }
} as const
```

### 2.2 모델 선택 기준

#### Google Gemini (기본 선택)

**모델**: `gemini-2.0-flash-exp`

**장점**:
- ✅ 빠른 응답 속도 (Flash 모델)
- ✅ 무료 할당량 제공 (분당 15 요청)
- ✅ JSON 모드 지원
- ✅ 한국어 성능 우수

**단점**:
- ⚠️ Experimental 버전 (안정성 향상 필요)

**비용**: 무료 (월 1,500 요청 제한)

#### OpenAI ChatGPT

**모델**: `gpt-4o-mini`

**장점**:
- ✅ 높은 품질
- ✅ 안정적 성능
- ✅ JSON 모드 지원
- ✅ 한국어 성능 우수

**단점**:
- ⚠️ 유료 서비스
- ⚠️ 상대적으로 느림

**비용**: 
- Input: $0.150 / 1M tokens
- Output: $0.600 / 1M tokens

#### Anthropic Claude

**모델**: `claude-3-5-haiku-20241022`

**장점**:
- ✅ 균형잡힌 성능
- ✅ 빠른 응답 (Haiku 모델)
- ✅ 안전성 강화

**단점**:
- ⚠️ 유료 서비스
- ⚠️ JSON 형식 응답 불안정

**비용**:
- Input: $1.00 / 1M tokens
- Output: $5.00 / 1M tokens

### 2.3 API 엔드포인트

```typescript
// Gemini API
const GEMINI_ENDPOINT = 
  'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent'

// OpenAI API
const OPENAI_ENDPOINT = 
  'https://api.openai.com/v1/chat/completions'

// Claude API
const CLAUDE_ENDPOINT = 
  'https://api.anthropic.com/v1/messages'
```

---

## 3. 시스템 프롬프트

### 3.1 프롬프트 구조

```
# Role
당신은 한국의 직장 문화와 커뮤니케이션에 매우 능숙한 AI 어시스턴트입니다.

# Instruction
주어진 'Original Text'를 아래 'Output Format'에 맞춰 세 가지 톤으로 변환하세요.

# 공통 다듬기 원칙
[공통 적용 규칙]

# Formal 가이드라인
[비즈니스 이메일용 상세 규칙]

# General 가이드라인
[사내 메신저용 상세 규칙]

# Friendly 가이드라인
[캐주얼 채팅용 상세 규칙]

# Tones
1. 격식 (Formal)
2. 일반 (General)
3. 친근 (Friendly)

# Output Format
{
  "formal": "...",
  "general": "...",
  "friendly": "..."
}

# Original Text
{{사용자_입력_텍스트}}
```

### 3.2 공통 다듬기 원칙

```
- 사용자가 입력한 내용을 빠짐없이 분석합니다.
- 복잡하거나 어색한 문장은 자연스럽고 읽기 쉽게 다듬습니다.
- 중문, 복문 등 사람이 이해하기 어려운 문장은 의미를 유지한 채 
  적절히 끊어 짧고 명확한 문장으로 재구성합니다.
- 정보의 사실관계, 의도, 요청/기한/책임 등 핵심 요소는 보존합니다.
- 비즈니스 상황에 적합한 어휘와 문체를 사용합니다.
```

### 3.3 Formal 가이드라인

**목적**: 비즈니스 이메일과 공식 문서용

**변환 규칙**:
```
- 반말 → 존댓말
- 직설적 표현 → 공손한 표현
- 명확성 유지와 적절한 공손함의 균형
- 요청: "번거로우시겠지만", "가능하시다면" 등 완곡 표현
- 거절: "아쉽지만", "다음을 기약하다" 등 유연한 표현
- 반대: "일리는 있지만", "그 점은 이해하지만" 등 상대 입장 인정
```

**제한사항**:
```
- 이모지 사용 금지
- 과도한 설명 제외
- 지나치게 굽히는 표현 지양
- 비즈니스 전문성 유지
```

### 3.4 General 가이드라인

**목적**: 팀 내 협업과 일상 업무 커뮤니케이션

**변환 규칙**:
```
- 존댓말 유지, 군더더기/중복 제거
- 핵심 먼저 제시
- 지시/요청은 주어·행동·기한·책임자 구성으로 명확히
- 제안/요청: "~하면 좋겠습니다", "~부탁드립니다"
- 피드백/반대: 사실→근거→제안 순서
- 긴 문장은 2~3개의 짧은 문장으로 분리
```

**제한사항**:
```
- 과도한 완곡/장식 금지
- 이모지, 구어체 과다 사용 금지
- 반말 금지
```

### 3.5 Friendly 가이드라인

**목적**: 동료 간 캐주얼하지만 예의를 갖춘 소통

**변환 규칙**:
```
- 존댓말 기반으로 부드럽고 따뜻한 어투
- 긍정적 도입/마무리: "도움 주셔서 감사합니다"
- 요청: "~가능하실까요?", "~부탁드려요"
- 거절/반대: 공감 표현 → 대안/제안
- 짧게 나누고 불필요한 수식어 제거
```

**제한사항**:
```
- 이모지/과한 유머/사적 호칭 금지
- 핵심 정보(요청/기한/책임)는 반드시 포함
```

### 3.6 프롬프트 생성 함수

```typescript
function createSystemPrompt(userText: string): string {
  return `
# Role
당신은 한국의 직장 문화와 커뮤니케이션에 매우 능숙한 AI 어시스턴트입니다.

[... 전체 프롬프트 ...]

# Original Text
${userText}`
}
```

**특징**:
- 사용자 입력 텍스트를 프롬프트 마지막에 삽입
- 일관된 형식 유지
- 모든 AI 제공업체에 동일한 프롬프트 사용

---

## 4. API 통합

### 4.1 통합 인터페이스

```typescript
export async function convertText(
  userText: string,      // 변환할 텍스트
  provider: AIProvider,  // 'gemini' | 'chatgpt' | 'claude'
  apiKey: string         // API 키
): Promise<AIApiResponse>
```

**반환 타입**:
```typescript
interface AIApiResponse {
  formal: string;    // 비즈니스 이메일 톤
  general: string;   // 사내 메신저 톤
  friendly: string;  // 캐주얼 채팅 톤
}
```

**프로세스**:
```
1. 입력 검증
   - 텍스트 비어있는지 확인
   - API 키 존재 확인
   ↓
2. 제공업체 선택
   - switch(provider) { ... }
   ↓
3. 해당 제공업체 API 호출
   - callGeminiAPI() / callOpenAIAPI() / callClaudeAPI()
   ↓
4. 응답 파싱
   - extractJsonFromResponse()
   ↓
5. 타입 변환 및 반환
   - AIApiResponse 형식으로 반환
```

### 4.2 Google Gemini API

**요청 페이로드**:
```typescript
interface GeminiApiRequest {
  contents: Array<{
    parts: Array<{
      text: string;  // 시스템 프롬프트 + 사용자 텍스트
    }>;
  }>;
  generationConfig: {
    temperature: number;        // 0.7
    maxOutputTokens: number;    // 1024
    candidateCount: number;     // 1
    topK: number;              // 40
    topP: number;              // 0.95
  };
  safetySettings: Array<{
    category: string;
    threshold: string;
  }>;
}
```

**페이로드 생성**:
```typescript
function createGeminiPayload(userText: string): GeminiApiRequest {
  return {
    contents: [{
      parts: [{
        text: createSystemPrompt(userText)
      }]
    }],
    generationConfig: {
      temperature: 0.7,
      maxOutputTokens: 1024,
      candidateCount: 1,
      topK: 40,
      topP: 0.95
    },
    safetySettings: [
      {
        category: "HARM_CATEGORY_HARASSMENT",
        threshold: "BLOCK_MEDIUM_AND_ABOVE"
      },
      {
        category: "HARM_CATEGORY_HATE_SPEECH",
        threshold: "BLOCK_MEDIUM_AND_ABOVE"
      }
    ]
  }
}
```

**API 호출**:
```typescript
async function callGeminiAPI(
  userText: string, 
  apiKey: string
): Promise<AIApiResponse> {
  const API_ENDPOINT = 
    'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent'
  
  const payload = createGeminiPayload(userText)
  
  // API 호출
  const response = await fetch(`${API_ENDPOINT}?key=${apiKey}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(payload)
  })
  
  // 에러 처리
  if (!response.ok) {
    if (response.status === 401 || response.status === 403) {
      throw new Error('Gemini API 키가 유효하지 않습니다.')
    } else if (response.status >= 500) {
      throw new Error('Gemini 서버에 문제가 발생했습니다.')
    }
    throw new Error(`Gemini API 호출 실패 (${response.status})`)
  }
  
  // 응답 파싱
  const data = await response.json()
  const responseText = data.candidates[0].content.parts[0].text
  
  return extractJsonFromResponse(responseText)
}
```

**응답 형식**:
```json
{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```json\n{\"formal\":\"...\",\"general\":\"...\",\"friendly\":\"...\"}\n```"
          }
        ]
      }
    }
  ]
}
```

### 4.3 OpenAI ChatGPT API

**요청 페이로드**:
```typescript
interface OpenAIApiRequest {
  model: string;           // "gpt-4o-mini"
  messages: Array<{
    role: 'system' | 'user' | 'assistant';
    content: string;
  }>;
  temperature: number;     // 0.7
  max_tokens: number;      // 1024
}
```

**페이로드 생성**:
```typescript
function createOpenAIPayload(userText: string): OpenAIApiRequest {
  return {
    model: "gpt-4o-mini",
    messages: [
      {
        role: "user",
        content: createSystemPrompt(userText)
      }
    ],
    temperature: 0.7,
    max_tokens: 1024
  }
}
```

**API 호출**:
```typescript
async function callOpenAIAPI(
  userText: string, 
  apiKey: string
): Promise<AIApiResponse> {
  const API_ENDPOINT = 'https://api.openai.com/v1/chat/completions'
  const payload = createOpenAIPayload(userText)
  
  const response = await fetch(API_ENDPOINT, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`  // Bearer 토큰 방식
    },
    body: JSON.stringify(payload)
  })
  
  // 에러 처리
  if (!response.ok) {
    if (response.status === 401) {
      throw new Error('OpenAI API 키가 유효하지 않습니다.')
    } else if (response.status === 429) {
      throw new Error('OpenAI API 사용량 한도에 도달했습니다.')
    } else if (response.status >= 500) {
      throw new Error('OpenAI 서버에 문제가 발생했습니다.')
    }
    throw new Error(`OpenAI API 호출 실패 (${response.status})`)
  }
  
  const data = await response.json()
  const responseText = data.choices[0].message.content
  
  return extractJsonFromResponse(responseText)
}
```

**응답 형식**:
```json
{
  "choices": [
    {
      "message": {
        "role": "assistant",
        "content": "{\"formal\":\"...\",\"general\":\"...\",\"friendly\":\"...\"}"
      }
    }
  ]
}
```

### 4.4 Anthropic Claude API

**요청 페이로드**:
```typescript
interface ClaudeApiRequest {
  model: string;           // "claude-3-5-haiku-20241022"
  max_tokens: number;      // 1024
  temperature: number;     // 0.7
  messages: Array<{
    role: 'user' | 'assistant';
    content: string;
  }>;
}
```

**페이로드 생성**:
```typescript
function createClaudePayload(userText: string): ClaudeApiRequest {
  return {
    model: "claude-3-5-haiku-20241022",
    max_tokens: 1024,
    temperature: 0.7,
    messages: [
      {
        role: "user",
        content: createSystemPrompt(userText)
      }
    ]
  }
}
```

**API 호출**:
```typescript
async function callClaudeAPI(
  userText: string, 
  apiKey: string
): Promise<AIApiResponse> {
  const API_ENDPOINT = 'https://api.anthropic.com/v1/messages'
  const payload = createClaudePayload(userText)
  
  const response = await fetch(API_ENDPOINT, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-api-key': apiKey,                          // 커스텀 헤더
      'anthropic-version': '2023-06-01'             // 버전 명시
    },
    body: JSON.stringify(payload)
  })
  
  // 에러 처리
  if (!response.ok) {
    if (response.status === 401) {
      throw new Error('Claude API 키가 유효하지 않습니다.')
    } else if (response.status === 429) {
      throw new Error('Claude API 사용량 한도에 도달했습니다.')
    } else if (response.status >= 500) {
      throw new Error('Claude 서버에 문제가 발생했습니다.')
    }
    throw new Error(`Claude API 호출 실패 (${response.status})`)
  }
  
  const data = await response.json()
  const responseText = data.content[0].text
  
  return extractJsonFromResponse(responseText)
}
```

**응답 형식**:
```json
{
  "content": [
    {
      "type": "text",
      "text": "{\"formal\":\"...\",\"general\":\"...\",\"friendly\":\"...\"}"
    }
  ]
}
```

---

## 5. 응답 처리

### 5.1 JSON 추출

**함수**:
```typescript
function extractJsonFromResponse(text: string): AIApiResponse
```

**프로세스**:
```
1. JSON 블록 찾기
   - 패턴 1: ```json ... ```
   - 패턴 2: { ... }
   ↓
2. 매칭 실패 시 에러
   throw new Error('API 응답에서 JSON을 찾을 수 없습니다.')
   ↓
3. JSON 파싱
   JSON.parse(jsonText)
   ↓
4. 필드 검증
   - formal 존재 확인
   - general 존재 확인
   - friendly 존재 확인
   ↓
5. 타입 변환 및 반환
   {
     formal: parsed.formal.trim(),
     general: parsed.general.trim(),
     friendly: parsed.friendly.trim()
   }
```

**구현**:
```typescript
function extractJsonFromResponse(text: string): AIApiResponse {
  // 1. JSON 블록 찾기
  const jsonMatch = text.match(/```json\s*([\s\S]*?)\s*```/) 
                    || text.match(/\{[\s\S]*\}/)
  
  if (!jsonMatch) {
    throw new Error('API 응답에서 JSON을 찾을 수 없습니다.')
  }
  
  try {
    // 2. JSON 파싱
    const jsonText = jsonMatch[1] || jsonMatch[0]
    const parsed = JSON.parse(jsonText)
    
    // 3. 필드 검증
    if (!parsed.formal || !parsed.general || !parsed.friendly) {
      throw new Error('API 응답 형식이 올바르지 않습니다.')
    }
    
    // 4. 반환
    return {
      formal: parsed.formal.trim(),
      general: parsed.general.trim(),
      friendly: parsed.friendly.trim()
    }
  } catch (error) {
    console.error('JSON parsing error:', error)
    throw new Error('API 응답을 파싱할 수 없습니다.')
  }
}
```

### 5.2 응답 예시

**입력**:
```
"이번 주까지 꼭 전달 부탁드립니다."
```

**출력**:
```json
{
  "formal": "업무에 참고할 수 있도록, 가능하시다면 이번 주 내로 자료를 전달해주시면 대단히 감사하겠습니다.",
  "general": "이번 주 안에 전달해주시면 업무 진행에 큰 도움이 될 것 같아요.",
  "friendly": "이번 주까지 꼭 부탁드려요!"
}
```

---

## 6. 에러 처리

### 6.1 에러 타입

**입력 검증 에러**:
```typescript
if (!userText.trim()) {
  throw new Error('변환할 텍스트를 입력해주세요.')
}

if (!apiKey) {
  throw new Error('API 키가 설정되지 않았습니다.')
}
```

**네트워크 에러**:
```typescript
try {
  const response = await fetch(API_ENDPOINT, { ... })
} catch (error) {
  throw new Error('네트워크 연결을 확인해주세요.')
}
```

**API 응답 에러**:

| 상태 코드 | 에러 메시지 |
|-----------|-------------|
| 401, 403 | "[제공업체] API 키가 유효하지 않습니다." |
| 429 | "[제공업체] API 사용량 한도에 도달했습니다." |
| 5xx | "[제공업체] 서버에 문제가 발생했습니다." |
| 기타 | "[제공업체] API 호출 실패 (코드)" |

**파싱 에러**:
```typescript
// JSON 찾기 실패
throw new Error('API 응답에서 JSON을 찾을 수 없습니다.')

// JSON 파싱 실패
throw new Error('API 응답을 파싱할 수 없습니다.')

// 필드 누락
throw new Error('API 응답 형식이 올바르지 않습니다.')
```

### 6.2 에러 처리 플로우

```
API 호출
   ↓
try-catch 블록
   ↓
에러 발생 시
   ↓
에러 타입 판별
   ├── Error 인스턴스 → 그대로 throw
   └── 기타 → '네트워크 연결 확인' 메시지
   ↓
상위 컴포넌트로 전파
   ↓
UI에 에러 메시지 표시
(Alert Component - destructive variant)
```

---

## 7. 성능 최적화

### 7.1 응답 시간 최적화

**목표**: 평균 2초 이하

**제공업체별 응답 시간** (평균):
- Gemini: 1-2초
- ChatGPT: 2-3초
- Claude: 1.5-2.5초

**최적화 기법**:
1. ✅ 경량 모델 사용 (Flash, Mini, Haiku)
2. ✅ 적절한 토큰 제한 (1024)
3. ✅ 타임아웃 설정 (10초)

### 7.2 네트워크 최적화

**HTTPS/2 사용**: ✅ 자동 지원

**요청 최소화**:
- 재시도 로직 없음 (사용자가 "다시 생성" 버튼 클릭)
- 병렬 요청 없음 (순차 처리)

**페이로드 최적화**:
- 불필요한 파라미터 제외
- 최소한의 설정만 사용

### 7.3 메모리 최적화

**응답 데이터 관리**:
- API 응답은 메모리에만 저장 (임시)
- 변환 결과는 UI 상태로만 관리
- 히스토리 저장 없음 (향후 개선 고려)

---

## 8. 테스트

### 8.1 단위 테스트

```typescript
describe('AI Integration', () => {
  test('JSON 추출 - 정상 케이스', () => {
    const text = '```json\n{"formal":"A","general":"B","friendly":"C"}\n```'
    const result = extractJsonFromResponse(text)
    expect(result).toEqual({
      formal: 'A',
      general: 'B',
      friendly: 'C'
    })
  })
  
  test('JSON 추출 - 필드 누락', () => {
    const text = '{"formal":"A","general":"B"}'
    expect(() => extractJsonFromResponse(text)).toThrow()
  })
  
  test('텍스트 변환 - 입력 검증', async () => {
    await expect(
      convertText('', 'gemini', 'api-key')
    ).rejects.toThrow('변환할 텍스트를 입력해주세요.')
  })
})
```

### 8.2 통합 테스트

```typescript
describe('API Integration Tests', () => {
  test('Gemini API 호출 - 성공', async () => {
    const result = await convertText(
      '테스트 문장', 
      'gemini', 
      VALID_GEMINI_KEY
    )
    expect(result.formal).toBeTruthy()
    expect(result.general).toBeTruthy()
    expect(result.friendly).toBeTruthy()
  })
  
  test('무효한 API 키 - 에러', async () => {
    await expect(
      convertText('테스트', 'gemini', 'invalid-key')
    ).rejects.toThrow('API 키가 유효하지 않습니다')
  })
})
```

---

**문서 작성**: AI 코드 분석 시스템  
**최종 업데이트**: 2025-12-25

